CAMERA
// .add_systems(Startup, debug_projection)

// fn debug_projection(query_camera: Query<&OrthographicProjection, With<MyCameraMarker>>) {
//     let projection = query_camera.single();
//     // ... do something with the projection
// }

// projection: OrthographicProjection {
            //     // don't forget to set `near` and `far`
            //     near: -1000.0,
            //     far: 1000.0,
            //     // ... any other settings you want to change ...
            //     ..default()
            // },

MAIN

// //! This example demonstrates how to load and unload maps.

// use bevy::prelude::*;
// use bevy_ecs_tiled::prelude::*;
// use bevy_ecs_tilemap::prelude::*;

// mod helper;
// mod playermovement;

// #[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash, States)]
// enum MapState {
//     Loaded,
//     #[default]
//     Unloaded,
// }

// fn main() {
//     App::new()
//         // Bevy default plugins
//         .add_plugins(DefaultPlugins)
//         // Examples helper plugin (does not matter for this example)
//         // .add_plugins(helper::HelperPlugin)
//         // bevy_ecs_tilemap and bevy_ecs_tiled main plugins
//         .add_plugins(TilemapPlugin)
//         .add_plugins(TiledMapPlugin::default())
//         // Add our systems and run the app!
//         .init_state::<MapState>()
//         .add_systems(Startup, startup)
//         .add_systems(
//             Update,
//             (
//                 handle_load.run_if(in_state(MapState::Unloaded)),
//                 (handle_unload, handle_reload, handle_respawn).run_if(in_state(MapState::Loaded)),
//             ),
//         )
//         .add_systems(Update, log_transitions)
//         .run();
// }

// fn startup(
//     mut commands: Commands,
//     mut asset_server: Res<AssetServer>,
//     mut next_state: ResMut<NextState<MapState>>,
// ) {
//     helper::load_sprite(&mut commands, &mut asset_server);
//     helper::load_tilemap(&mut commands, &mut asset_server);
//     next_state.set(MapState::Loaded);
// }

// fn handle_load(
//     mut commands: Commands,
//     mut asset_server: Res<AssetServer>,
//     keyboard_input: Res<ButtonInput<KeyCode>>,
//     mut next_state: ResMut<NextState<MapState>>,
// ) {
//     if keyboard_input.just_pressed(KeyCode::KeyL) {
//         helper::load_sprite(&mut commands, &mut asset_server);
//         helper::load_tilemap(&mut commands, &mut asset_server);
//         next_state.set(MapState::Loaded);
//     }
// }

// fn handle_reload(
//     mut commands: Commands,
//     asset_server: Res<AssetServer>,
//     keyboard_input: Res<ButtonInput<KeyCode>>,
//     maps_query: Query<Entity, With<TiledMapMarker>>,
//     mut next_state: ResMut<NextState<MapState>>,
// ) {
//     if keyboard_input.just_pressed(KeyCode::KeyK) {
//         if let Ok(entity) = maps_query.get_single() {
//             commands
//                 .entity(entity)
//                 .insert(TiledMapHandle(asset_server.load("tilemap_level1.tmx")));
//         } else {
//             warn!("Cannot reload: no map loaded ?");
//         }

//         next_state.set(MapState::Loaded);
//     }
// }

// fn handle_unload(
//     mut commands: Commands,
//     mut maps: ResMut<Assets<TiledMap>>,
//     keyboard_input: Res<ButtonInput<KeyCode>>,
//     maps_query: Query<Entity, With<TiledMapMarker>>,
//     mut next_state: ResMut<NextState<MapState>>,
// ) {
//     if keyboard_input.just_pressed(KeyCode::KeyU) {
//         // This example shows that the map gets properly unloaded if the
//         // `TiledMap` asset is removed.
//         //
//         // However, typically you would remove the map entity instead.
//         let handles: Vec<_> = maps.iter().map(|(handle, _)| handle).collect();
//         for handle in handles {
//             // This will cause the map to unload.
//             maps.remove(handle);
//         }

//         // Actually remove the entities, so that we can re-add later.
//         // If we don't do this, the entity still exists and the map will not be
//         // reloaded properly.
//         for entity in maps_query.iter() {
//             commands.entity(entity).despawn_recursive();
//         }
//         next_state.set(MapState::Unloaded);
//     } else if keyboard_input.just_pressed(KeyCode::KeyI) {
//         // Just remove the entities directly. This will also unload the map.
//         for entity in maps_query.iter() {
//             commands.entity(entity).despawn_recursive();
//         }
//         next_state.set(MapState::Unloaded);
//     }
// }

// fn handle_respawn(
//     mut commands: Commands,
//     keyboard_input: Res<ButtonInput<KeyCode>>,
//     maps_query: Query<Entity, With<TiledMapMarker>>,
// ) {
//     if keyboard_input.just_pressed(KeyCode::KeyR) {
//         if let Ok(entity) = maps_query.get_single() {
//             commands.entity(entity).insert(RespawnTiledMap);
//         } else {
//             warn!("Cannot respawn: no map loaded ?");
//         }
//     }
// }

// fn log_transitions(mut transitions: EventReader<StateTransitionEvent<MapState>>) {
//     for transition in transitions.read() {
//         info!(
//             "transition: {:?} => {:?}",
//             transition.exited, transition.entered
//         );
//     }
// }

HELPER 
// use bevy::{color::palettes::css::PURPLE, prelude::*};
// use bevy_ecs_tiled::prelude::*;
// use bevy_ecs_tilemap::prelude::*;

// #[derive(Component, Debug)]
// struct Player {
//     speed: f32,
// }

// #[derive(Debug)]
// enum GameStatus {
//     Ongoing,
//     Won,
//     Lost,
// }

// #[derive(Debug)]
// struct GameState {
//     status: GameStatus,
// }

// #[derive(Debug)]
// struct Score {
//     value: i32,
// }

// fn main() {
//     App::new()
//         // Add Bevy default plugins
//         .add_plugins(DefaultPlugins)
//         .add_plugins(WindowPlugin {
//             primary_window: Some(Window {
//                 resolution: (140.0, 140.0).into(),
//                 title: "It's Just Business".to_string(),
//                 ..default()
//             }),
//             ..default()
//         })
//         .add_plugins(DefaultPlugins)
//         // Add bevy_ecs_tilemap plugin
//         .add_plugins(TilemapPlugin)
//         // Add bevy_ecs_tiled plugin
//         .add_plugins(TiledMapPlugin::default())
//         // .add_startup_system(load_tilemap)
//         .run();
// }

// pub fn load_sprite(commands: &mut Commands, asset_server: &mut Res<AssetServer>) {
//     commands.spawn(SpriteBundle {
//         texture: asset_server.load("janitor-v1.png"),
//         transform: Transform::from_xyz(30.0, 3.0, 3.0),
//         ..Default::default()
//     });
// }

// pub fn load_tilemap(commands: &mut Commands, asset_server: &mut Res<AssetServer>) {
//     commands.spawn((
//         TiledMapHandle(asset_server.load("tilemap_level1.tmx")),
//         Transform::from_translation(Vec3::new(0.0, 0.0, 0.0)), // Adjust these values
//         GlobalTransform::default(),
//     ));
// }

// /* OLD CODE: */
// // Spawn a 2D camera
// // commands.spawn(Camera2dBundle::default());

// // Load the map: ensure any tile / tileset paths are relative to assets/ folder
// // let map_handle: Handle<TiledMap> = asset_server.load("tilemap_level1.tmx");

// // Spawn the map with default options
// // commands.spawn(TiledMapHandle(map_handle));


// fn spriteMove(commands: Commands, sprite: SpriteBundle) {
//     // Create a single animation (tween) to move an entity.
//     let tween = Tween::new(
//         // Use a quadratic easing on both endpoints.
//         EaseFunction::QuadraticInOut,
//         // Animation time.
//         Duration::from_secs(1),
//         // The lens gives access to the Transform component of the Entity,
//         // for the Animator to animate it. It also contains the start and
//         // end values respectively associated with the progress ratios 0. and 1.
//         TransformPositionLens {
//             start: Vec3::ZERO,
//             end: Vec3::new(1., 2., -4.),
//         },
//     );

//     commands.spawn((
//         // Spawn an entity to animate the position of.
//         TransformBundle::default(),
//         // Add an Animator component to control and execute the animation.
//         Animator::new(tween),
//     ));
// }